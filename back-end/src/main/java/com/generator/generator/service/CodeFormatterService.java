package com.generator.generator.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.regex.Pattern;

/**
 * Service to post-process generated code and fix common formatting issues
 * that occur when LLM generates code without proper spacing/newlines.
 */
@Service
@Slf4j
public class CodeFormatterService {

    // Patterns for common concatenated keywords
    private static final Pattern ANNOTATION_BEFORE_KEYWORD = Pattern.compile("(@\\w+)(public|private|protected|class|interface|enum)");
    private static final Pattern CONCATENATED_KEYWORDS = Pattern.compile("(public|private|protected|static|final|abstract)(class|interface|enum|void|String|int|long|boolean|List|Map|Set)");
    private static final Pattern IMPORT_WITHOUT_SPACE = Pattern.compile("import([a-z])");
    private static final Pattern PACKAGE_WITHOUT_SPACE = Pattern.compile("package([a-z])");
    
    /**
     * Post-processes generated code to fix common formatting issues.
     * 
     * @param rawCode The raw code generated by LLM
     * @return Formatted code with proper spacing and newlines
     */
    public String formatGeneratedCode(String rawCode) {
        if (rawCode == null || rawCode.trim().isEmpty()) {
            return rawCode;
        }
        
        log.debug("Formatting generated code (input length: {} chars)", rawCode.length());
        
        String formatted = rawCode;
        
        // 1. Fix concatenated keywords (highest priority)
        formatted = fixConcatenatedKeywords(formatted);
        
        // 2. Fix missing newlines
        formatted = fixMissingNewlines(formatted);
        
        // 3. Fix import and package statements
        formatted = fixImportAndPackageStatements(formatted);
        
        // 4. Fix annotation formatting
        formatted = fixAnnotationFormatting(formatted);
        
        // 5. Fix method and field declarations
        formatted = fixMethodAndFieldDeclarations(formatted);
        
        // 6. Fix brace formatting
        formatted = fixBraceFormatting(formatted);
        
        // 7. Basic indentation normalization
        formatted = normalizeIndentation(formatted);
        
        log.debug("Code formatting completed (output length: {} chars)", formatted.length());
        
        return formatted;
    }
    
    /**
     * Fixes concatenated keywords like "publicclass", "privateString", etc.
     */
    private String fixConcatenatedKeywords(String code) {
        // Fix common concatenated patterns
        code = code.replaceAll("publicclass", "public class");
        code = code.replaceAll("publicinterface", "public interface");
        code = code.replaceAll("publicenum", "public enum");
        code = code.replaceAll("privateclass", "private class");
        code = code.replaceAll("privateinterface", "private interface");
        code = code.replaceAll("protectedclass", "protected class");
        
        // Fix static/final combinations
        code = code.replaceAll("staticfinal", "static final");
        code = code.replaceAll("publicstatic", "public static");
        code = code.replaceAll("privatestatic", "private static");
        code = code.replaceAll("publicfinal", "public final");
        code = code.replaceAll("privatefinal", "private final");
        
        // Fix type concatenations
        code = code.replaceAll("privateString", "private String");
        code = code.replaceAll("privateLong", "private Long");
        code = code.replaceAll("privateInteger", "private Integer");
        code = code.replaceAll("privateBoolean", "private boolean");
        code = code.replaceAll("privateList", "private List");
        code = code.replaceAll("privateMap", "private Map");
        code = code.replaceAll("privateSet", "private Set");
        code = code.replaceAll("privateboolean", "private boolean");
        code = code.replaceAll("publicString", "public String");
        code = code.replaceAll("publicLong", "public Long");
        code = code.replaceAll("publicList", "public List");
        
        // Fix return type concatenations
        code = code.replaceAll("publicvoid", "public void");
        code = code.replaceAll("privatevoid", "private void");
        code = code.replaceAll("publicString", "public String");
        code = code.replaceAll("publicLong", "public Long");
        code = code.replaceAll("publicList", "public List");
        code = code.replaceAll("publicTask", "public Task");
        code = code.replaceAll("publicResponseEntity", "public ResponseEntity");
        
        // Fix @Entity, @Service, etc. concatenations
        code = code.replaceAll("@Entitypublic", "@Entity\npublic");
        code = code.replaceAll("@Entity@Table", "@Entity\n@Table");
        code = code.replaceAll("@Servicepublic", "@Service\npublic");
        code = code.replaceAll("@RestControllerpublic", "@RestController\npublic");
        code = code.replaceAll("@Autowiredprivate", "@Autowired\n    private");
        code = code.replaceAll("@Id@GeneratedValue", "@Id\n    @GeneratedValue");
        code = code.replaceAll("@Table\\s*\\(name", "@Table(name");
        code = code.replaceAll("@Table\\s*\\(name=", "@Table(name=");
        
        // Fix common annotation concatenations without space
        code = code.replaceAll("(@\\w+)(public|private|protected|class|interface|enum)", "$1\n$2");
        
        // Fix extends/implements concatenations
        code = code.replaceAll("extendsJpaRepository", "extends JpaRepository");
        code = code.replaceAll("implementsITaskService", "implements ITaskService");
        code = code.replaceAll("implementsITodoService", "implements ITodoService");
        
        return code;
    }
    
    /**
     * Fixes missing newlines between code blocks.
     */
    private String fixMissingNewlines(String code) {
        // Ensure newline after closing brace before next keyword
        code = code.replaceAll("\\}\\s*(public|private|protected|class|interface|enum|@)", "}\n$1");
        
        // Ensure newline after semicolon before next statement (in some cases)
        code = code.replaceAll(";\\s*(public|private|protected|@\\w+)", ";\n$1");
        
        // Ensure newline between class/interface declarations
        code = code.replaceAll("}\\s*public\\s+class", "}\n\npublic class");
        code = code.replaceAll("}\\s*public\\s+interface", "}\n\npublic interface");
        
        // Fix comments concatenated with code
        code = code.replaceAll("//([A-Z])([a-z])", "// $1$2");
        code = code.replaceAll("//GettersandSetters", "// Getters and Setters");
        code = code.replaceAll("//Getters", "// Getters");
        code = code.replaceAll("//Setters", "// Setters");
        
        // Ensure newline after package declaration
        code = code.replaceAll("package\\s+[^;]+;\\s*([^\\n])", "package $1;\n\n$1");
        code = code.replaceAll("package\\s+[^;]+;([^\\n])", "package $1;\n$1");
        
        // Fix multiple closing braces without newlines
        code = code.replaceAll("}\\s*}\\s*}", "}\n    }\n}");
        
        return code;
    }
    
    /**
     * Fixes import and package statements that are missing spaces.
     */
    private String fixImportAndPackageStatements(String code) {
        // Fix import statements: "importjakarta" -> "import jakarta"
        // Match "import" followed by lowercase letter (common patterns)
        code = code.replaceAll("import(jakarta|javax|org|com|java)(\\.)", "import $1$2");
        code = code.replaceAll("import([a-z])", "import $1");
        code = code.replaceAll("import\\s+([a-z])", "import $1");
        
        // Fix package statements: "packagecom" -> "package com"
        code = code.replaceAll("package(jakarta|javax|org|com|java)(\\.)", "package $1$2");
        code = code.replaceAll("package([a-z])", "package $1");
        code = code.replaceAll("package\\s+([a-z])", "package $1");
        
        // Ensure semicolon after import/package
        code = code.replaceAll("import\\s+([^;]+)([^;\\n])", "import $1;");
        code = code.replaceAll("package\\s+([^;]+)([^;\\n])", "package $1;");
        
        return code;
    }
    
    /**
     * Fixes annotation formatting issues.
     */
    private String fixAnnotationFormatting(String code) {
        // Add newline after annotations before class/interface/method
        code = code.replaceAll("(@\\w+)\\s*(public|private|protected|class|interface)", "$1\n$2");
        code = code.replaceAll("(@\\w+\\s*\\([^)]*\\))\\s*(public|private|protected|class|interface)", "$1\n$2");
        
        // Fix multiple annotations on same line
        code = code.replaceAll("@(\\w+)\\s*@(\\w+)", "@$1\n@$2");
        
        // Ensure proper spacing in annotation parameters
        code = code.replaceAll("@RequestMapping\\(\"([^\"]+)\"\\)", "@RequestMapping(\"$1\")");
        code = code.replaceAll("@GetMapping\\(\"([^\"]+)\"\\)", "@GetMapping(\"$1\")");
        code = code.replaceAll("@PostMapping\\(\"([^\"]+)\"\\)", "@PostMapping(\"$1\")");
        
        return code;
    }
    
    /**
     * Fixes method and field declaration formatting.
     */
    private String fixMethodAndFieldDeclarations(String code) {
        // Fix field declarations: "privateStringdescription;" -> "private String description;"
        code = code.replaceAll("(private|public|protected)\\s*(String|Long|Integer|Boolean|List|Map|Set|Date)([a-z])", "$1 $2 $3");
        
        // Fix method declarations: "publicvoidmethodName" -> "public void methodName"
        code = code.replaceAll("(public|private|protected)\\s*(void|String|Long|Integer|Boolean|List|Map|Set|Task|ResponseEntity)([a-z])", "$1 $2 $3");
        
        // Fix field declarations without space: "privateLongid" -> "private Long id"
        code = code.replaceAll("(private|public|protected)(Long|String|Integer|Boolean|List|Map|Set|Date|Task)([a-z])([^;]*;)", "$1 $2 $3$4");
        
        // Fix return statements: "returnid;" -> "return id;"
        code = code.replaceAll("return([a-z])", "return $1");
        code = code.replaceAll("return([A-Z])", "return $1");
        
        // Fix this assignments: "this.id=id:" -> "this.id = id;"
        code = code.replaceAll("this\\.([a-z]+)=([^;]+):", "this.$1 = $2;");
        code = code.replaceAll("this\\.([a-z]+)=([^;]+);", "this.$1 = $2;");
        
        // Fix return type spacing: "publicList<Task>" -> "public List<Task>"
        code = code.replaceAll("(public|private|protected)(List|Map|Set)<", "$1 $2<");
        code = code.replaceAll("(public|private|protected)(ResponseEntity)<", "$1 $2<");
        
        // Fix parameter declarations: "@RequestBodyTasktask" -> "@RequestBody Task task"
        code = code.replaceAll("@RequestBody([A-Z])([a-z])", "@RequestBody $1$2");
        code = code.replaceAll("@PathVariable([A-Z])([a-z])", "@PathVariable $1$2");
        code = code.replaceAll("@RequestParam\\([^)]+\\)([A-Z])([a-z])", "@RequestParam(...) $1$2");
        
        return code;
    }
    
    /**
     * Fixes brace formatting issues.
     */
    private String fixBraceFormatting(String code) {
        // Ensure space before opening brace: "classTask{" -> "class Task {"
        code = code.replaceAll("(class|interface|enum|if|else|for|while|switch|catch)\\s*([A-Z]\\w*)\\{", "$1 $2 {");
        
        // Ensure newline after opening brace
        code = code.replaceAll("\\{\\s*([^\\n}])", "{\n    $1");
        
        // Ensure proper spacing around braces in method calls
        code = code.replaceAll("(\\w+)\\(\\)\\{", "$1() {");
        
        return code;
    }
    
    /**
     * Normalizes basic indentation (simple approach - can be enhanced).
     */
    private String normalizeIndentation(String code) {
        // This is a basic implementation
        // For production, consider using JavaParser or similar library
        
        // Ensure consistent line breaks
        code = code.replaceAll("\\r\\n", "\n");
        code = code.replaceAll("\\r", "\n");
        
        // Remove excessive blank lines (more than 2 consecutive)
        code = code.replaceAll("\\n{4,}", "\n\n\n");
        
        // Ensure at least one newline between class definitions
        code = code.replaceAll("}\\s*public\\s+class", "}\n\npublic class");
        code = code.replaceAll("}\\s*public\\s+interface", "}\n\npublic interface");
        
        return code;
    }
    
    /**
     * Formats a specific file's content based on its type.
     */
    public String formatFileContent(String content, String filePath) {
        if (content == null || content.trim().isEmpty()) {
            return content;
        }
        
        if (filePath.endsWith(".java")) {
            return formatJavaCode(content);
        } else if (filePath.endsWith(".xml")) {
            return formatXmlCode(content);
        } else if (filePath.endsWith(".properties") || filePath.endsWith(".yml") || filePath.endsWith(".yaml")) {
            return formatPropertiesCode(content);
        } else if (filePath.endsWith(".json")) {
            return formatJsonCode(content);
        }
        
        return formatGeneratedCode(content);
    }
    
    /**
     * Formats Java code specifically.
     */
    private String formatJavaCode(String code) {
        return formatGeneratedCode(code);
    }
    
    /**
     * Formats XML code (pom.xml, etc.).
     */
    private String formatXmlCode(String code) {
        // Basic XML formatting
        code = code.replaceAll("><", ">\n<");
        code = code.replaceAll("</([^>]+)><", "</$1>\n<");
        return code;
    }
    
    /**
     * Formats properties files.
     */
    private String formatPropertiesCode(String code) {
        // Ensure each property is on its own line
        code = code.replaceAll("([^\\n])(spring\\.)", "$1\n$2");
        code = code.replaceAll("([^\\n])(#)", "$1\n$2");
        return code;
    }
    
    /**
     * Formats JSON code.
     */
    private String formatJsonCode(String code) {
        // Basic JSON formatting - ensure proper spacing
        code = code.replaceAll("\\{([^}]+)\\}", "{\n    $1\n}");
        code = code.replaceAll("\"([^\"]+)\":([^,}]+)", "\"$1\": $2");
        return code;
    }
}


